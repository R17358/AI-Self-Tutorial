# -*- coding: utf-8 -*-
"""sentiment-ANN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nyrElfvgyHqSGu5cS9ErVFQFRvqIa4TF
"""

from google.colab import files
files.upload()

!pip install kaggle

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

# Set permissions for the file
!chmod 600 ~/.kaggle/kaggle.json

import kagglehub

# Download latest version
path = kagglehub.dataset_download("columbine/imdb-dataset-sentiment-analysis-in-csv-format")

print("Path to dataset files:", path)

import os

# List files in the dataset directory
dataset_dir = path
files = os.listdir(dataset_dir)

print("Available files:", files)

data_path = os.path.join(dataset_dir, "Train.csv")

import pandas as pd
# Load the dataset
df = pd.read_csv(data_path)

# Check the first few rows of the dataframe to understand its structure
print(df.head())

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_files
import numpy as np


# Prepare the data (text and labels)
texts = df['text'].values
labels = df['label'].values

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(texts, labels, test_size=0.3, random_state=42)

# Convert text to TF-IDF features
vectorizer = TfidfVectorizer(max_features=5000)
X_train_tfidf = vectorizer.fit_transform(X_train).toarray()
X_test_tfidf = vectorizer.transform(X_test).toarray()

# Build the ANN model
model = Sequential([
    Dense(128, input_dim=X_train_tfidf.shape[1], activation='relu'),
    Dense(64, activation='relu'),
    Dense(1, activation='sigmoid')  # Sigmoid for binary classification (positive/negative)
])

# Compile the model
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

# Train the model
model.fit(X_train_tfidf, y_train, epochs=5, batch_size=64, validation_data=(X_test_tfidf, y_test))

# Evaluate the model
test_loss, test_acc = model.evaluate(X_test_tfidf, y_test)
print(f"Test Accuracy: {test_acc}")

# Function to predict sentiment for a new text
def predict_sentiment(text):
    # Transform the text using the pre-trained TF-IDF vectorizer
    tfidf_text = vectorizer.transform([text]).toarray()

    # Make prediction using the trained model
    prediction = model.predict(tfidf_text)

    # Return sentiment based on prediction (threshold of 0.5 for binary classification)
    if prediction >= 0.5:
        return "Positive"
    else:
        return "Negative"

# Example usage
new_text = "This movie was absolutely amazing!"
print(f"Sentiment: {predict_sentiment(new_text)}")

user_input = input("Enter a text: ")
print(f"Sentiment: {predict_sentiment(user_input)}")

